/*
 * HDF5-UDF: User-Defined Functions for HDF5
 *
 * File: python_backend.cpp
 *
 * Python code parser and bytecode generation/execution.
 */
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <errno.h>
#include <glob.h>
#include <fstream>
#include <sstream>
#include <string>
#include <algorithm>
#include "python_backend.h"
#include "anon_mmap.h"
#include "dataset.h"
#ifdef ENABLE_SANDBOX
#include "sandbox.h"
#endif

// Dataset names, sizes, and types
static std::vector<DatasetInfo> dataset_info;

/* Functions exported to the Python template library (udf_template.py) */
extern "C" void *pythonGetData(const char *element)
{
    for (size_t i=0; i<dataset_info.size(); ++i)
        if (dataset_info[i].name.compare(element) == 0)
            return dataset_info[i].data;
    fprintf(stderr, "%s: dataset %s not found\n", __func__, element);
    return NULL;
}

extern "C" const char *pythonGetType(const char *element)
{
    for (size_t i=0; i<dataset_info.size(); ++i)
        if (dataset_info[i].name.compare(element) == 0)
            return dataset_info[i].getDatatype();
    fprintf(stderr, "%s: dataset %s not found\n", __func__, element);
    return NULL;
}

extern "C" const char *pythonGetCast(const char *element)
{
    for (size_t i=0; i<dataset_info.size(); ++i)
        if (dataset_info[i].name.compare(element) == 0)
            return dataset_info[i].getCastDatatype();
    fprintf(stderr, "%s: dataset %s not found\n", __func__, element);
    return NULL;
}

extern "C" const char *pythonGetDims(const char *element)
{
    for (size_t i=0; i<dataset_info.size(); ++i)
        if (dataset_info[i].name.compare(element) == 0)
            return dataset_info[i].dimensions_str.c_str();
    fprintf(stderr, "%s: dataset %s not found\n", __func__, element);
    return NULL;
}

/* This backend's name */
std::string PythonBackend::name()
{
    return "CPython";
}

/* Extension managed by this backend */
std::string PythonBackend::extension()
{
    return ".py";
}

/* Compile Python to a bytecode. Returns the bytecode as a string object. */
std::string PythonBackend::compile(std::string udf_file, std::string template_file)
{
    std::string placeholder = "# user_callback_placeholder";
    auto py_file = Backend::assembleUDF(udf_file, template_file, placeholder, this->extension());
    if (py_file.size() == 0)
    {
        fprintf(stderr, "Will not be able to compile the UDF code\n");
        return "";
    }

    pid_t pid = fork();
    if (pid == 0)
    {
        // Child process
        char *cmd[] = {
            (char *) "python3",
            (char *) "-m",
            (char *) "compileall",
            (char *) "-l",         // don't recurse into subdirectories
            (char *) "-f",         // force rebuild even if timestamps are up to date
            (char *) py_file.c_str(),
            (char *) NULL
        };
        execvp(cmd[0], cmd);
    }
    else if (pid > 0)
    {
        // Parent
        int exit_status;
        wait4(pid, &exit_status, 0, NULL);

        // Find the bytecode
        auto sep = py_file.find_last_of('/');
        if (sep == std::string::npos)
        {
            fprintf(stderr, "Failed to identify directory where assembled file was saved\n");
            unlink(py_file.c_str());
            return "";
        }
        std::string parentdir = py_file.substr(0, sep);
        std::string filename = py_file.substr(sep + 1);
        sep = filename.find_last_of(".");
        filename = filename.substr(0, sep);

        // Because the Python version is part of the generated file name, we resort to glob()
        // to identify the actual path to that file.
        glob_t results;
        std::stringstream pycache, pattern;
        pycache << parentdir << "/__pycache__";
        pattern << pycache.str() << "/" << filename << ".cpython-*.pyc";
        int ret = glob(pattern.str().c_str(), GLOB_NOSORT, NULL, &results);
        if (ret != 0 || results.gl_pathc == 0)
        {
            fprintf(stderr, "No bytecodes were found under %s\n", pattern.str().c_str());
            unlink(py_file.c_str());
            rmdir(pycache.str().c_str());
            if (ret == 0) { globfree(&results); }
            return "";
        }

        // Assume the very first match is the one we're looking for
        std::string pyc_file = results.gl_pathv[0];
        globfree(&results);
        printf("Bytecode found at %s\n", pyc_file.c_str());

        // Read generated bytecode
        std::string bytecode;
        std::ifstream data(pyc_file, std::ifstream::binary);
        std::vector<unsigned char> buffer(std::istreambuf_iterator<char>(data), {});
        bytecode.assign(buffer.begin(), buffer.end());
        
        unlink(py_file.c_str());
        unlink(pyc_file.c_str());
        rmdir(pycache.str().c_str());
        return bytecode;
    }
    fprintf(stderr, "Failed to execute python3\n");
    return "";
}

/* Execute the user-defined-function embedded in the given buffer */
bool PythonBackend::run(
    const std::string filterpath,
    const std::vector<DatasetInfo> input_datasets,
    const DatasetInfo output_dataset,
    const char *output_cast_datatype,
    const char *bytecode,
    size_t bytecode_size)
{
    if (bytecode_size < 16)
    {
        fprintf(stderr, "Error: Python bytecode is too small to be valid\n");
        return false;
    }

    /*
     * We want to make the output dataset writeable by the UDF. Because
     * the UDF is run under a separate process we have to use a shared
     * memory segment which both processes can read and write to.
     */
    size_t room_size = output_dataset.getGridSize() * output_dataset.getStorageSize();
    AnonymousMemoryMap mm(room_size);
    if (! mm.create())
        return false;

    // Let output_dataset.data point to the shared memory segment
    DatasetInfo output_dataset_copy = output_dataset;
    output_dataset_copy.data = mm.mm;

    // Populate global vector of dataset names, sizes, and types
    dataset_info.push_back(output_dataset_copy);
    dataset_info.insert(
        dataset_info.end(), input_datasets.begin(), input_datasets.end());

    // Workaround for CFFI import errors due to missing symbols. We force libpython
    // to be loaded and for all symbols to be resolved by dlopen()
    void *libpython = dlopen("libpython3.so", RTLD_NOW | RTLD_GLOBAL);

    // Init Python interpreter
    Py_Initialize();

    // We have to check whether this offset is fixed at all times or if can
    // change. Some docs mention an offset of 8 bytes, for instance.
    bytecode = &bytecode[16];
    bytecode_size -= 16;

    // Get a reference to the code object we compiled before
    PyObject *obj = PyMarshal_ReadObjectFromString(bytecode, bytecode_size);
    if (! obj)
    {
        PyObject *err = PyErr_Occurred();
        if (err && (
            PyErr_GivenExceptionMatches(err, PyExc_EOFError) ||
            PyErr_GivenExceptionMatches(err, PyExc_ValueError) ||
            PyErr_GivenExceptionMatches(err, PyExc_TypeError)))
        {
            PyErr_Print();
        }
        PyErr_Clear();
        Py_Finalize();
        dlclose(libpython);
        return false;
    }

    PyObject *module = PyImport_ExecCodeModule("udf_module", obj);
    if (! module)
    {
        fprintf(stderr, "Failed to import code object\n");
        PyErr_Print();
        Py_Finalize();
        dlclose(libpython);
        return false;
    }

    bool retval = false;
    PyObject *dict = PyModule_GetDict(module);
    PyObject *lib = dict ? PyDict_GetItemString(dict, "lib") : NULL;
    PyObject *loadlib = lib ? PyObject_GetAttrString(lib, "load") : NULL;
    PyObject *udf = dict ? PyDict_GetItemString(dict, "dynamic_dataset") : NULL;
    if (! lib || ! loadlib || ! udf)
        fprintf(stderr, "Failed to load required symbols from code object\n");
    else if (! PyCallable_Check(loadlib))
        fprintf(stderr, "Error: lib.load is not a callable function\n");
    else if (! PyCallable_Check(udf))
        fprintf(stderr, "Error: dynamic_dataset is not a callable function\n");
    else
    {
        retval = executeUDF(loadlib, udf, filterpath);
        if (retval == true)
        {
            // Update output HDF5 dataset with data from shared memory segment
            memcpy(output_dataset.data, mm.mm, room_size);
        }
    }

    Py_DECREF(module);
    Py_DECREF(dict);
    Py_Finalize();
    dlclose(libpython);

    return retval;
}

/* Coordinate the execution of the UDF under a separate process */
bool PythonBackend::executeUDF(PyObject *loadlib, PyObject *udf, std::string filterpath)
{
    /*
     * Execute the user-defined-function under a separate process so that
     * seccomp can kill it (if needed) without crashing the entire program
     */
    pid_t pid = fork();
    if (pid == 0)
    {
        // Run 'lib.load(filterpath)' from our udf_template.py
        // TODO: load the template straight from /usr/share, as
        // the function that comes with the UDF may not be trustable.
        PyObject *pyargs = PyTuple_New(1);
        PyObject *pypath = Py_BuildValue("s", filterpath.c_str());
        PyTuple_SetItem(pyargs, 0, pypath);
        PyObject *callret = PyObject_CallObject(loadlib, pyargs);
        if (callret)
            Py_DECREF(callret);

        bool ready = true;
#ifdef ENABLE_SANDBOX
        Sandbox sandbox;
        ready = sandbox.init(filterpath);
#endif
        if (ready)
        {
            // Run 'dynamic_dataset()' defined by the user
            callret = PyObject_CallObject(udf, NULL);
            if (callret)
                Py_DECREF(callret);
            else
            {
                // Function call terminated by an exception
                PyErr_Print();
                PyErr_Clear();
                ready = false;
            }
            Py_DECREF(pypath);
            Py_DECREF(pyargs);
        }
        // Exit the process without invoking any callbacks registered with atexit()
        _exit(ready ? 0 : 1);
    }
    else if (pid > 0)
    {
        int status;
        waitpid(pid, &status, 0);
        return WIFEXITED(status) ? WEXITSTATUS(status) == 0 : false;
    }
    return false;
}

void PythonBackend::printPyObject(PyObject *obj)
{
    PyObject *repr = PyObject_Repr(obj);
    const char *s = PyUnicode_AsUTF8(repr);
    printf("%p=%s\n", repr, s);
}

/* Scan the UDF file for references to HDF5 dataset names */
std::vector<std::string> PythonBackend::udfDatasetNames(std::string udf_file)
{
    std::string input;
    std::ifstream data(udf_file, std::ifstream::binary);
    std::vector<unsigned char> buffer(std::istreambuf_iterator<char>(data), {});
    input.assign(buffer.begin(), buffer.end());

    std::string line;
    std::istringstream iss(input);
    std::vector<std::string> output;

    auto ltrim = [](std::string &s) {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
            return !std::isspace(ch);
        }));
    };

    while (std::getline(iss, line))
    {
        ltrim(line);
        auto n = line.find("lib.getData");
        auto c = line.find("#");
        if (n != std::string::npos && (c == std::string::npos || c > n))
        {
            auto start = line.substr(n).find_first_of("\"");
            auto end = line.substr(n+start+1).find_first_of("\"");
            auto name = line.substr(n).substr(start+1, end);
            output.push_back(name);
        }
    }
    return output;
}
